复杂度:
	常见时间复杂度分析方法:
	1.树循环次数
	2.均摊分析
	3.递归式-主定理
	
	复杂度:
	O(1):基本运算
	O(log n):二分查找，分治
	O(n(1/2)(此处是指数)):枚举约束
	O(n):线性查找
	O(n*n):朴素最近点对
	O(n*n*n):Floyd最短路,普通矩阵乘法
	O(nlogn):归并排序,快速排序的期望复杂度,基于比较排序的算法下界
	O(2的n次方):枚举全部的子集
	O(n!):枚举全排列
	
	总结:O(1)<O(logn)<O(n的1/2次方)<O(n)<O(nlogn)
	可能可以优化:O(n*n)<O(n*n*n)<O(2的n次方)<O(n!)
	
均摊分析:多个操作，一起算时间复杂度
	MULTIPOP队列，可以一次性出队K个元素
	C++里Vector的实现:动态数组,插满后会开辟一个2倍大小的空间并把原来的数据复制过来(释放原来的空间),每次copy数据的时间复杂度是O(n)
	插入N个数的复杂度是O(n),一共有n个元素,均摊来说，每次插入的复杂度就是O(1)
	
例题
	最大子数组和:给定数组,求最大子数组和
	暴力枚举(O(n*n*n))
	优化枚举(O(n*n))
	贪心法(O(n))